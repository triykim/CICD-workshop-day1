// Phase 6: Add Artifacts
// Goal: Create and archive build artifacts

pipeline {
    agent any
    
    triggers {
        // Poll SCM every minute for changes
        pollSCM('* * * * *')
        // Or use GitHub webhook trigger (configure in Jenkins job settings)
        // githubPush()
    }
    
    environment {
        PROJECT_NAME = 'GoWebApp'
        BUILD_NUMBER = "${env.BUILD_NUMBER}"
        GO_VERSION = '1.21.5'
        GOLANGCI_LINT_VERSION = '1.55.2'
        GOPATH = "${WORKSPACE}/go"
        PATH = "/usr/local/go/bin:${GOPATH}/bin:${PATH}"
    }
    
    stages {
        stage('Cleanup Workspace') {
            steps {
                echo 'ðŸ§¹ Cleaning workspace before build...'
                deleteDir()
                echo 'âœ… Workspace cleaned'
            }
        }
        
        stage('Checkout') {
            steps {
                echo 'ðŸ“¦ Checking out source code from GitHub...'
                checkout scm
            }
        }
        
        stage('Setup Go Environment') {
            steps {
                echo 'ðŸ”§ Setting up Go environment...'
                sh '''
                    if ! command -v go &> /dev/null; then
                        ARCH=$(uname -m)
                        case ${ARCH} in
                            x86_64) GO_ARCH="amd64" ;;
                            aarch64|arm64) GO_ARCH="arm64" ;;
                            *) echo "Unsupported architecture: ${ARCH}"; exit 1 ;;
                        esac
                        
                        GO_TARBALL="go${GO_VERSION}.linux-${GO_ARCH}.tar.gz"
                        GO_URL="https://go.dev/dl/${GO_TARBALL}"
                        
                        curl -fsSL -o ${GO_TARBALL} ${GO_URL}
                        rm -rf /usr/local/go
                        tar -C /usr/local -xzf ${GO_TARBALL}
                        rm ${GO_TARBALL}
                    fi
                    
                    go version
                '''
            }
        }
        
        stage('Install Dependencies') {
            steps {
                echo 'ðŸ“¥ Installing Go dependencies...'
                sh '''
                    go mod download
                    go mod verify
                '''
            }
        }
        
        stage('Static Code Analysis') {
            steps {
                echo 'ðŸ” Running static code analysis...'
                sh '''
                    if ! command -v golangci-lint &> /dev/null; then
                        ARCH=$(uname -m)
                        case ${ARCH} in
                            x86_64) LINT_ARCH="amd64" ;;
                            aarch64|arm64) LINT_ARCH="arm64" ;;
                            *) echo "Unsupported architecture: ${ARCH}"; exit 1 ;;
                        esac
                        
                        LINT_URL="https://github.com/golangci/golangci-lint/releases/download/v${GOLANGCI_LINT_VERSION}/golangci-lint-${GOLANGCI_LINT_VERSION}-linux-${LINT_ARCH}.tar.gz"
                        curl -fsSL -o golangci-lint.tar.gz ${LINT_URL}
                        tar -xzf golangci-lint.tar.gz
                        mkdir -p ${GOPATH}/bin
                        mv golangci-lint-${GOLANGCI_LINT_VERSION}-linux-${LINT_ARCH}/golangci-lint ${GOPATH}/bin/
                        rm -rf golangci-lint*
                    fi
                    
                    golangci-lint run --timeout 5m ./...
                    go vet ./...
                    
                    UNFORMATTED=$(gofmt -l .)
                    if [ -n "$UNFORMATTED" ]; then
                        echo "âŒ Unformatted files: $UNFORMATTED"
                        exit 1
                    fi
                    
                    echo "âœ… All static analysis checks passed!"
                '''
            }
        }
        
        stage('Build') {
            steps {
                echo 'ðŸ”¨ Building Go application...'
                sh '''
                    mkdir -p bin
                    
                    COMMIT=$(git rev-parse --short HEAD)
                    BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S_UTC')
                    
                    go build -v \
                        -ldflags="-X main.version=1.0.${BUILD_NUMBER} -X main.commit=${COMMIT} -X main.buildTime=${BUILD_TIME}" \
                        -o bin/${PROJECT_NAME} \
                        ./cmd/webapp
                    
                    ls -lh bin/${PROJECT_NAME}
                    echo "âœ… Build completed successfully!"
                '''
            }
        }
        
        stage('Test') {
            steps {
                echo 'ðŸ§ª Running tests...'
                sh '''
                    if ! command -v go-junit-report &> /dev/null; then
                        go install github.com/jstemmer/go-junit-report/v2@latest
                    fi
                    
                    mkdir -p test-reports
                    
                    # Run tests and capture output
                    set +e
                    go test -v -coverprofile=coverage.out -covermode=atomic ./... 2>&1 | tee test-output.txt
                    TEST_EXIT=$?
                    set -e
                    
                    # Generate JUnit report
                    cat test-output.txt | go-junit-report -set-exit-code > test-reports/junit.xml
                    
                    # Generate HTML coverage report
                    go tool cover -html=coverage.out -o coverage.html
                    
                    echo ""
                    echo "ðŸ“Š Coverage Summary:"
                    go tool cover -func=coverage.out | tail -n 1
                    
                    exit ${TEST_EXIT}
                '''
            }
            post {
                always {
                    junit 'test-reports/*.xml'
                }
            }
        }
        
        stage('Create Artifacts') {
            steps {
                echo 'ðŸ“¦ Creating build artifacts...'
                sh '''
                    # Create artifacts directory
                    mkdir -p artifacts
                    
                    # Copy binary
                    cp bin/${PROJECT_NAME} artifacts/
                    
                    # Copy coverage reports
                    cp coverage.out coverage.html artifacts/
                    
                    # Create build info
                    cat > artifacts/build-info.json << EOF
{
  "version": "1.0.${BUILD_NUMBER}",
  "commit": "$(git rev-parse HEAD)",
  "commit_short": "$(git rev-parse --short HEAD)",
  "branch": "$(git branch --show-current || echo 'detached HEAD')",
  "build_time": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
  "build_number": "${BUILD_NUMBER}",
  "jenkins_url": "${BUILD_URL}"
}
EOF
                    
                    # Create run script
                    cat > artifacts/run.sh << 'EOF'
#!/bin/bash
PORT=${PORT:-8090}
echo "Starting GoWebApp on port ${PORT}..."
./GoWebApp
EOF
                    chmod +x artifacts/run.sh
                    
                    # Create tarball
                    COMMIT=$(git rev-parse --short HEAD)
                    ARTIFACT_NAME="${PROJECT_NAME}-1.0.${BUILD_NUMBER}-${COMMIT}.tar.gz"
                    tar -czf artifacts/${ARTIFACT_NAME} -C artifacts ${PROJECT_NAME} run.sh build-info.json coverage.out coverage.html
                    
                    echo ""
                    echo "âœ… Artifacts created:"
                    ls -lh artifacts/
                '''
            }
        }
        
        stage('Archive Artifacts') {
            steps {
                echo 'ðŸ“š Archiving artifacts...'
                archiveArtifacts artifacts: 'artifacts/**/*', fingerprint: true
                
                echo 'âœ… Artifacts archived in Jenkins'
                echo 'Download artifacts from: ${BUILD_URL}artifact/'
            }
        }
    }
    
    post {
        success {
            echo 'âœ… Pipeline completed successfully!'
            echo ''
            echo 'ðŸ“Š Build Summary:'
            echo "Build Number: ${BUILD_NUMBER}"
            echo "Status: ${currentBuild.currentResult}"
        }
        failure {
            echo 'âŒ Pipeline failed!'
            echo 'Check the logs above for error details.'
        }
        always {
            script {
                echo 'ðŸ§¹ Cleaning up...'
                echo "Build ${BUILD_NUMBER} finished with status: ${currentBuild.currentResult}"
            }
        }
    }
}
